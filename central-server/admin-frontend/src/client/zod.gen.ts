// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

export const zUserType = z.enum(['student', 'staff']);

export const zUserStatus = z.enum([
    'active',
    'inactive',
    'dismissed'
]);

export const zBiometricEnrollmentStatus = z.enum(['pending', 'completed']);

export const zUser = z.object({
    fname: z.string(),
    lname: z.string(),
    email: z.string(),
    user_type: zUserType,
    status: z.optional(zUserStatus),
    biometric_enrollment_status: z.optional(zBiometricEnrollmentStatus)
});

export const zUserCreate = zUser.and(z.object({
    role_id: z.optional(z.int()),
    class_id: z.optional(z.int()),
    regno: z.optional(z.string())
}));

export const zUserResponse = zUserCreate.and(z.object({
    id: z.optional(z.int()),
    created_at: z.optional(z.iso.datetime())
}));

export const zRole = z.object({
    role_name: z.string(),
    description: z.optional(z.string())
});

export const zRoleResponse = zRole.and(z.object({
    id: z.optional(z.int())
}));

export const zBranch = z.object({
    name: z.string(),
    location: z.optional(z.string()),
    description: z.optional(z.string()),
    status: z.optional(z.enum(['active', 'revoked']))
});

export const zBranchResponse = zBranch.and(z.object({
    id: z.optional(z.int()),
    admin_id: z.optional(z.int()),
    date_created: z.optional(z.iso.datetime())
}));

export const zGroup = z.object({
    branch_id: z.int(),
    grouptype_id: z.int(),
    name: z.string(),
    expected_weekly_hours: z.optional(z.int()),
    absence_threshold: z.int(),
    supervisors: z.optional(z.array(z.object({
        user_id: z.optional(z.int())
    })))
});

export const zGroupResponse = zGroup.and(z.object({
    id: z.optional(z.int()),
    date_created: z.optional(z.iso.datetime())
}));

export const zSubgroup = z.object({
    group_id: z.int(),
    name: z.string(),
    absence_threshold: z.int(),
    created_by: z.optional(z.int())
});

export const zSubgroupResponse = zSubgroup.and(z.object({
    id: z.optional(z.int()),
    date_created: z.optional(z.iso.datetime())
}));

export const zPermissionRequest = z.object({
    permissiontype_id: z.optional(z.int()),
    user_id: z.optional(z.int()),
    initiatedby: z.optional(z.int()),
    reason: z.optional(z.string()),
    start_date: z.optional(z.iso.date()),
    end_date: z.optional(z.iso.date()),
    status: z.optional(z.enum([
        'pending',
        'approved',
        'rejected'
    ])),
    additional_proof: z.optional(z.string()),
    requested_at: z.optional(z.iso.datetime())
});

export const zPermissionApproval = z.object({
    permission_id: z.optional(z.int()),
    approver_id: z.optional(z.int()),
    remark: z.optional(z.string()),
    status: z.optional(z.enum([
        'pending',
        'approved',
        'rejected'
    ]))
});

export const zAnnoucement = z.object({
    name: z.optional(z.string()),
    message: z.optional(z.string()),
    start_datetime: z.optional(z.iso.datetime()),
    end_datetime: z.optional(z.iso.datetime()),
    created_by: z.optional(z.int())
});

export const zAnnouncementResponse = zAnnoucement.and(z.object({
    id: z.optional(z.int()),
    date_created: z.optional(z.iso.datetime())
}));

export const zEvent = z.object({
    name: z.optional(z.string()),
    group_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    subgroup_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    start_datetime: z.optional(z.iso.datetime()),
    end_datetime: z.optional(z.iso.datetime()),
    affects_attendance: z.optional(z.boolean()).default(true),
    handshake: z.optional(z.union([z.literal(1), z.literal(2)])),
    created_by: z.optional(z.int())
});

export const zEventCheckinCheckoutRange = z.object({
    checkin_start_datetime: z.optional(z.iso.datetime()),
    checkin_end_datetime: z.optional(z.iso.datetime()),
    checkout_start_datetime: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    checkout_end_datetime: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

export const zEventCreate = zEvent.and(z.object({
    checkin_ranges: z.optional(zEventCheckinCheckoutRange)
}));

export const zEventResponse = zEvent.and(z.object({
    id: z.optional(z.int())
}));

export const zException = z.object({
    exception_type_id: z.optional(z.int()),
    description: z.optional(z.string()),
    start_date: z.optional(z.iso.date()),
    end_date: z.optional(z.iso.date()),
    created_by: z.optional(z.int())
});

export const zExceptionResponse = zException.and(z.object({
    id: z.optional(z.int())
}));

export const zTerminal = z.object({
    name: z.optional(z.string()),
    activation_code: z.optional(z.string()),
    branch_id: z.optional(z.int()),
    slug: z.optional(z.string()),
    status: z.optional(z.enum([
        'pending',
        'active',
        'revoked'
    ]))
});

export const zTerminalAuthTypes = z.enum([
    'face',
    'card',
    'fingerprint'
]);

/**
 * This defines the type of auth supported by the terminal
 */
export const zTerminalCapabilities = z.object({
    auth_type_id: z.optional(z.int())
});

/**
 * groups/subgroups allowed to auth at this terminal
 */
export const zTerminalAccessPolicy = z.object({
    group_id: z.optional(z.int()),
    subgroup_id: z.optional(z.int()),
    auth_type_id: z.optional(z.int()),
    auth_step: z.optional(z.int())
});

export const zTerminalCreate = zTerminal.and(z.object({
    auth_capabilities: z.optional(z.array(zTerminalCapabilities)),
    access_policy: z.optional(z.array(zTerminalAccessPolicy))
}));

export const zTerminalResponse = zTerminal.and(z.object({
    id: z.optional(z.int()),
    date_created: z.optional(z.iso.datetime())
}));

export const zBiometricFaceEnrollRequest = z.object({
    user_id: z.int(),
    face_image: z.string()
});

export const zBiometricFaceEnrollResponse = z.object({
    message: z.string(),
    biometric_profile_id: z.int()
});

export const zBiometricFaceVerifyRequest = z.object({
    terminal_id: z.int(),
    face_image: z.string()
});

export const zBiometricFaceVerifyResponse = z.object({
    matched: z.boolean(),
    user_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    confidence_score: z.optional(z.number()),
    message: z.optional(z.string())
});

export const zAttendanceStatus = z.object({
    name: z.optional(z.enum([
        'present',
        'absent',
        'late',
        'on permission'
    ]))
});

/**
 * track progress throughout the auth sequence
 */
export const zTerminalAuthSession = z.object({
    user_id: z.optional(z.int()),
    terminal_id: z.optional(z.int()),
    current_step: z.optional(z.int()).default(1),
    status: z.optional(z.enum(['in_progress', 'completed']))
});

/**
 * logs each auth attemp, ie record is created for each completed auth session
 */
export const zTerminalAuthLog = z.object({
    user_id: z.optional(z.int()),
    terminal_id: z.optional(z.int()),
    attendance_context: z.optional(z.enum(['daily', 'event'])),
    event_id: z.optional(z.int()),
    auth_type_id: z.optional(z.int())
});

/**
 * Represents attendance after auth successs
 * ie upon successfull checkin and checkout for daily attendance
 * or checkin and/or checkout for event attendance depending on the handshake
 *
 */
export const zTerminalAttendanceSession = z.object({
    user_id: z.optional(z.int()),
    terminal_id: z.optional(z.int()),
    attendance_context: z.optional(z.enum(['daily', 'event'])),
    event_id: z.optional(z.int()),
    checkin_timestamp: z.optional(z.iso.datetime()),
    checkout_timestamp: z.optional(z.iso.datetime()),
    checkin_status: z.optional(z.enum(['on time', 'late'])),
    checkout_status: z.optional(z.enum(['on time', 'early'])),
    session_status: z.optional(z.enum([
        'active',
        'completed',
        'missed checkout'
    ])),
    sync_status: z.optional(z.enum([
        'pending',
        'synced',
        'error'
    ]))
});

/**
 * Summary of the daily/event attendance, this is the record that get sync to the central db
 * Was the user present, late or on permission for this day
 *
 */
export const zTerminalAttendanceSummary = z.object({
    user_id: z.optional(z.int()),
    terminal_id: z.optional(z.int()),
    attendance_date: z.optional(z.iso.date()),
    attendance_context: z.optional(z.enum(['daily', 'event'])),
    event_id: z.optional(z.int()),
    first_checkin: z.optional(z.iso.datetime()),
    last_checkout: z.optional(z.iso.datetime()),
    total_hours: z.optional(z.int()),
    attendance_status: z.optional(z.int()),
    derived_from_session: z.optional(z.boolean())
});

export const zTerminalAuthCreate = zTerminalAuthSession.and(z.object({
    terminal_auth_log: z.optional(zTerminalAuthLog.and(z.record(z.string(), z.unknown())))
}));

export const zTerminalAuthInProgressResponse = z.object({
    status: z.enum(['in_progress']),
    current_step: z.int(),
    next_auth_type_id: z.int()
});

export const zTerminalAuthCompletedResponse = z.object({
    status: z.enum(['completed']),
    message: z.optional(z.string()),
    attendance_session: zTerminalAttendanceSession
});

export const zTerminalAttendanceSummaryCreate = zTerminalAttendanceSummary.and(z.record(z.string(), z.unknown()));

export const zLogs = z.object({
    category: z.optional(z.string()),
    description: z.optional(z.string()),
    user_id: z.optional(z.int())
});

export const zListUsersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        user_type: z.optional(zUserType),
        status: z.optional(zUserStatus)
    }))
});

/**
 * List of users
 */
export const zListUsersResponse = z.array(zUserResponse);

export const zCreateUserData = z.object({
    body: zUserCreate,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * User created successfully
 */
export const zCreateUserResponse = zUserResponse;

export const zDeleteUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.int()
    }),
    query: z.optional(z.never())
});

export const zGetUserByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * User found
 */
export const zGetUserByIdResponse = zUserResponse;

export const zUpdateUserData = z.object({
    body: zUserCreate,
    path: z.object({
        id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * User updated successfully
 */
export const zUpdateUserResponse = zUserResponse;

export const zListRolesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Roles list
 */
export const zListRolesResponse = z.array(zRoleResponse);

export const zListBranchesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * List of branches
 */
export const zListBranchesResponse = z.array(zBranchResponse);

export const zCreateBranchData = z.object({
    body: zBranch.and(z.object({
        user_id: z.optional(z.int())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Branch created successfully
 */
export const zCreateBranchResponse = zBranchResponse;

export const zUpdateBranchData = z.object({
    body: z.optional(zBranch.and(z.object({
        user_id: z.optional(z.int())
    }))),
    path: z.object({
        id: z.int()
    }),
    query: z.optional(z.never())
});

export const zCreateGroupTypeData = z.object({
    body: z.object({
        name: z.string(),
        abbreviation: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListGroupsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Groups list
 */
export const zListGroupsResponse = z.array(zGroupResponse);

export const zCreateGroupData = z.object({
    body: zGroup,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zAssignUsersToGroupData = z.object({
    body: z.optional(z.object({
        group_id: z.optional(z.int()),
        user_ids: z.optional(z.array(z.int()))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListSubgroupsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

export const zCreateSubgroupData = z.object({
    body: z.optional(zSubgroup),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

export const zAssignUsersToSubgroupData = z.object({
    body: z.optional(z.object({
        subgroup_id: z.optional(z.int()),
        user_ids: z.optional(z.array(z.int()))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCreatePermissionRequestData = z.object({
    body: zPermissionRequest.and(z.record(z.string(), z.unknown())),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDecidePermissionRequestData = z.object({
    body: zPermissionApproval.and(z.record(z.string(), z.unknown())),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListAnnouncementsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        group_id: z.optional(z.int()),
        subgroup_id: z.optional(z.int())
    }))
});

/**
 * List of events (optionally filtered by group or subgroup)
 */
export const zListAnnouncementsResponse = z.array(zAnnouncementResponse);

export const zCreateAnnouncementData = z.object({
    body: zAnnoucement.and(z.object({
        group_id: z.array(z.int()),
        subgroup_id: z.array(z.int())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListEventsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        group_id: z.optional(z.int()),
        subgroup_id: z.optional(z.int())
    }))
});

/**
 * List of events (optionally filtered by group or subgroup)
 */
export const zListEventsResponse = z.array(zEventResponse);

export const zCreateEventData = z.object({
    body: zEventCreate,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListExceptionsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * List of exceptions
 */
export const zListExceptionsResponse = z.array(zExceptionResponse);

export const zCreateExceptionData = z.object({
    body: zException,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCreateTerminalData = z.object({
    body: zTerminalCreate,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListTerminalsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        branchid: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * List of all terminals at that branch
 */
export const zListTerminalsResponse = z.array(zTerminalCreate);

export const zTerminalCapabilitiesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        terminalId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * List the auth types supported by this terminal
 */
export const zTerminalCapabilitiesResponse = z.array(zTerminalCreate);

export const zTerminalAuthData = z.object({
    body: zTerminalAuthCreate,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Authentication successful, if there are more auth types to complete, the response will indicate
 */
export const zTerminalAuthResponse = z.union([
    zTerminalAuthInProgressResponse,
    zTerminalAuthCompletedResponse
]);

export const zSyncAttendanceSummaryData = z.object({
    body: z.array(zTerminalAttendanceSummaryCreate),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Attendance summary synced
 */
export const zSyncAttendanceSummaryResponse = z.union([
    z.object({
        message: z.optional(z.string())
    }),
    z.object({
        message: z.optional(z.string()),
        failed_records: z.optional(z.array(z.object({
            user_id: z.optional(z.int()),
            terminal_id: z.optional(z.int()),
            attendance_date: z.optional(z.iso.date()),
            attendance_context: z.optional(z.string()),
            attendance_status: z.optional(z.int()),
            error_message: z.optional(z.string())
        })))
    })
]);

export const zFaceEnrollmentData = z.object({
    body: zBiometricFaceEnrollRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * face enrollment successfull
 */
export const zFaceEnrollmentResponse = zBiometricFaceEnrollResponse;

export const zFaceVerificationData = z.object({
    body: zBiometricFaceVerifyRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * face verification result
 */
export const zFaceVerificationResponse = zBiometricFaceVerifyResponse;
